using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Windows.Forms;


namespace Rhino.UI
{
  /// <summary>
  /// Used a placeholded which is used by LocalizationProcessor application to create contextId
  /// mapped localized strings
  /// </summary>
  public static class LOC
  {
    ///<summary>
    /// Strings that need to be localized should call this function. The STR function doesn't actually
    /// do anything but return the original string. The LocalizationProcessor application walks
    /// through the source code of a project and looks for LOC.STR. The function is then replaced with a
    /// call to Localization.LocalizeString using a unique context ID.
    ///</summary>
    ///<param name='english'>[in] The English string to localize</param>
    public static string STR(string english)
    {
      return english;
    }

    ///<summary>
    /// Command names that need to be localized should call this function. The COMMANDNAME function doesn't actually
    /// do anything but return the original string. The LocalizationProcessor application walks
    /// through the source code of a project and looks for LOC.COMMANDNAME and builds a record for each command
    /// name for the translators that can be used by developers in a commands overridden Rhino.Commands.Command.LocalName
    /// which should call Rhino.UI.Localization.LocalizeCommandName(EnglishName)
    ///</summary>
    ///<param name='english'>[in] The English string to localize</param>
    public static string COMMANDNAME(string english)
    {
      return english;
    }

    /// <summary>
    /// Similar to String::Format function
    /// </summary>
    /// <param name="english"></param>
    /// <param name="arg0"></param>
    /// <returns></returns>
    public static string STR(string english, object arg0)
    {
      return string.Format(english, arg0);
    }

    /// <summary>
    /// Command option name strings that need to be localized should call this function. The CON function
    /// doesn't actually do anything but return the original string. The LocalizationProcessor application walks
    /// through the source code of a project and looks for LOC.CON. The function is then replaced with a
    /// call to Localization.LocalizeCommandOptionName using a unique context ID.
    ///</summary>
    ///<param name='english'>[in] The English string to localize</param>
    /// <returns>Returns localized string pair with both the English and local names set to the English value</returns>
    public static LocalizeStringPair CON(string english)
    {
      return new LocalizeStringPair(english, english);
    }

    /// <summary>
    /// Command option name strings that need to be localized should call this function. The COV function
    /// doesn't actually do anything but return the original string. The LocalizationProcessor application walks
    /// through the source code of a project and looks for LOC.COV. The function is then replaced with a
    /// call to Localization.LocalizeCommandOptionValue using a unique context ID.
    ///</summary>
    ///<param name='engilsh'>[in] The English string to localize</param>
    /// <returns>Returns localized string pair with both the English and local names set to the English value</returns>
    public static LocalizeStringPair COV(string engilsh)
    {
      return new LocalizeStringPair(engilsh, engilsh);
    }
  }

  public static class Localization
  {
    /// <summary>
    /// Returns localized version of a given English string. This function should be autogenerated by the
    /// RmaLDotNetLocalizationProcessor application for every function that uses RMASTR
    /// </summary>
    /// <param name="english"></param>
    /// <param name="contextId"></param>
    /// <returns></returns>
    public static string LocalizeString(string english, int contextId)
    {
      Assembly a = Assembly.GetCallingAssembly();
      return LocalizeStringInAssembly(english, contextId, a);
    }

    /// <summary>
    /// Similar to String::Format function
    /// </summary>
    /// <param name="english"></param>
    /// <param name="contextId"></param>
    /// <param name="arg0"></param>
    /// <returns></returns>
    public static string LocalizeString(string english, int contextId, object arg0)
    {
      Assembly a = Assembly.GetCallingAssembly();
      return LocalizeStringInAssembly(english, contextId, arg0, a);
    }


    public static string LocalizeStringInAssembly(string english, int contextId, Assembly assembly)
    {
      return LocalizationUtils.LocalizeString(assembly, CurrentLanguageID, english, contextId);
    }


    public static string LocalizeStringInAssembly(string english, int contextId, object arg0, Assembly assembly)
    {
      string s = LocalizeStringInAssembly(english, contextId, assembly);
      return string.Format(s, arg0);
    }

    ///<summary>
    /// Commands that need to be localized should call this function.
    ///</summary>
    ///<param name='englishCommandName'></param>
    public static string LocalizeCommandName(string englishCommandName)
    {
      Assembly a = Assembly.GetCallingAssembly();
      return LocalizationUtils.LocalizeCommandName(a, CurrentLanguageID, englishCommandName);
    }

    public static string LocalizeCommandNameInAssembly(string english, Assembly assembly)
    {
      return LocalizationUtils.LocalizeCommandName(assembly, CurrentLanguageID, english);
    }

    public static LocalizeStringPair LocalizeCommandOptionName(string english, int contextId)
    {
      Assembly a = Assembly.GetCallingAssembly();
      string local = LocalizeStringInAssembly(english, contextId, a);
      return new LocalizeStringPair(english, local);
    }

    public static LocalizeStringPair LocalizeCommandOptionValue(string english, int contextId)
    {
      Assembly a = Assembly.GetCallingAssembly();
      string local = LocalizeStringInAssembly(english, contextId, a);
      return new LocalizeStringPair(english, local);
    }

    ///<summary>
    /// A form or user control should call this in its constructor if it wants to be localized
    /// the typical constructor for a localize form would look like:
    /// MyForm::MyForm()
    /// {
    ///   SuspendLayout();
    ///   InitializeComponent();
    ///   Rhino.UI.Localize.LocalizeForm( this );
    ///   ResumeLayout(true);
    /// }
    ///</summary>
    public static void LocalizeForm(Control form)
    {
      Assembly a = Assembly.GetCallingAssembly();
      LocalizeForm(form, a);
    }

    public static void LocalizeForm(Control form, Assembly assembly)
    {
      LocalizationUtils.LocalizeForm(assembly, CurrentLanguageID, form);
    }

    ///<summary>
    /// A form or user control should call this in its constructor if it wants to localize
    /// context menus that are set on the fly and not assigned to a forms control in design
    /// studio.
    /// MyForm::MyForm()
    /// {
    ///   SuspendLayout();
    ///   InitializeComponent();
    ///   Rhino.UI.Localize.LocalizeToolStripItemCollection( this, this.MyToolStrip.Items );
    /// }
    ///</summary>
    public static void LocalizeToolStripItemCollection(Control parent, ToolStripItemCollection collection)
    {
      Assembly a = Assembly.GetCallingAssembly();
      LocalizeToolStripItemCollection(parent, collection, a);
    }

    public static void LocalizeToolStripItemCollection(Control parent, ToolStripItemCollection collection, Assembly assembly)
    {
      LocalizationUtils.LocalizeToolStripItemCollection(assembly, CurrentLanguageID, parent, collection);
    }

    static int m_language_id = -1;
    static int CurrentLanguageID
    {
      get
      {
        // we don't want the language id to change since Rhino in general does not
        // support swapping localizations on the fly. Use a cached language id after the
        // initial language id has been read
        if (m_language_id == -1)
        {
#if RHINO_SDK
          // This code is commonly called while working in theVisual Studio designer
          // and we want to try and not throw exceptions in order to show the winform
          if (Rhino.Runtime.HostUtils.RunningInRhino)
            m_language_id = Rhino.ApplicationSettings.AppearanceSettings.LanguageIdentifier;
          else
            m_language_id = 1033;
#else
          m_language_id = 1033;
#endif
        }
        return m_language_id;
      }
    }
  }

  /// <summary>
  /// Pair of strings used for localization
  /// </summary>
  public sealed class LocalizeStringPair
  {
    public LocalizeStringPair(string english, string local)
    {
      m_english = english;
      m_local = local;
    }
    string m_english, m_local;
    public string English { get { return m_english; } }
    public string Local { get { return m_local; } }
  }
}
