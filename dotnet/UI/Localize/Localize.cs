using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Windows.Forms;

using RMA.Rhino;

// RMA_DONT_LOCALIZE

namespace Rhino.UI
{
  internal static class Localize
  {
    /// <summary>
    /// 
    /// </summary>
    static Localize()
    {
      m_current_language_id = 1033;
    }
    ///<summary>
    /// The localization system initially starts up with a language id of 1033 (English).
    /// Use this function to reset this ID to the current application language id.
    ///
    /// Rhino.NET will automatically set this up so it should not be the responsibility
    /// of plug-ins to know when to set the language_id value.
    ///</summary>
    ///<param name="language_id">
    /// language identifier that will be used to look up localization information
    /// in Rhino this can be found at RhinoApp().AppSettings().AppearanceSettings().m_language_identifier
    ///</param>
    ///<returns> true if successful</returns>
    public static bool SetCurrentLanguageID(uint language_id)
    {
      //TODO: add some checks to see if language_id is a valid value
      if (Localize.m_current_language_id != language_id)
      {
        // don't fire a change event if the language id doesn't actually change
        Localize.m_current_language_id = language_id;
        if (null != Localize.LanguageIdChange)
          Localize.LanguageIdChange.Invoke(m_current_language_id);
      }
      return true;
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="language_id"></param>
    public delegate void LocalizeLanguageIdHandler(uint language_id);
    /// <summary>
    /// Event handler to notify when language ID changes
    /// </summary>
    public static event LocalizeLanguageIdHandler LanguageIdChange;
    /// <summary>
    /// 
    /// </summary>
    public static uint CurrentLanguageID { get { return Localize.m_current_language_id; } }
    ///<summary>
    /// Strings that need to be localized should call this function. The RMASTR function doesn't actually
    /// do anything but return the original string. The RmaDotNetLocalizationProcessor application walks
    /// through the source code of a project and looks for RMASTR. The function is then replaced with a
    /// call to RmaLocalizeString using a unique context ID.
    ///</summary>
    ///<param name='english_str'>[in] The string to localize</param>
    public static string RMASTR(string english_str)
    {
      return english_str;
    }
    /// <summary>
    /// Similar to String::Format function
    /// </summary>
    /// <param name="english_str"></param>
    /// <param name="arg0"></param>
    /// <returns></returns>
    public static string RMASTR(string english_str, object arg0)
    {
      return string.Format(english_str, arg0);
    }
    /// <summary>
    /// Returns a localized version of a given English string. This function should be autogenerated by the
    /// RmaLDotNetLocalizationProcessor application for every function that uses RMASTR
    /// </summary>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <returns></returns>
    public static string RMALocalizeString(string english_str, int context_id)
    {
      return Localize.RMALocalizeStringInAssembly(Assembly.GetCallingAssembly(), english_str, context_id);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="a"></param>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <returns></returns>
    public static string RMALocalizeStringInAssembly(Assembly a, string english_str, int context_id)
    {
      return LocalizeUtils.LocalizeString(a, Localize.m_current_language_id, english_str, context_id);
    }
    /// <summary>
    /// Similar to String::Format function
    /// </summary>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <param name="arg0"></param>
    /// <returns></returns>
    public static string RMALocalizeString(string english_str, int context_id, object arg0)
    {
      return RMALocalizeStringInAssembly(Assembly.GetCallingAssembly(), english_str, context_id, arg0);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="a"></param>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <param name="arg0"></param>
    /// <returns></returns>
    public static string RMALocalizeStringInAssembly(Assembly a, string english_str, int context_id, object arg0)
    {
      string s = LocalizeUtils.LocalizeString(a, Localize.m_current_language_id, english_str, context_id);
      return string.Format(s, arg0);
    }
    ///<summary>
    /// Commands that need to be localized should call this function.
    ///</summary>
    ///<param name='english_command_name'>[in] The string to localize</param>
    public static string RMACOMMANDNAME(string english_command_name)
    {
      return LocalizeUtils.LocalizeString(Assembly.GetCallingAssembly(), Localize.m_current_language_id, english_command_name);
    }
    ///<summary>
    /// Command option names that need to be localized should call this function. The RMACON function doesn't actually
    /// do anything but return the original string. The RmaDotNetLocalizationProcessor application walks
    /// through the source code of a project and looks for RHCON. The function is then replaced with a
    /// call to RmaLocalizeCON using a unique context ID.
    ///</summary>
    ///<param name='english_str'>[in] The string to localize</param>
    public static MRhinoCommandOptionName RMACON(string english_str)
    {
      return new MRhinoCommandOptionName(english_str, null);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <returns></returns>
    public static MRhinoCommandOptionName RMALocalizeCON(string english_str, int context_id)
    {
      string s = Localize.RMALocalizeString(english_str, context_id);
      if (string.IsNullOrEmpty(s))
        s = english_str;
      return new MRhinoCommandOptionName(english_str, s);
    }
    ///<summary>
    /// Command option values that need to be localized should call this function. The RMACOV function doesn't actually
    /// do anything but return the original string. The RmaDotNetLocalizationProcessor application walks
    /// through the source code of a project and looks for RHCON. The function is then replaced with a
    /// call to RmaLocalizeCOV using a unique context ID.
    ///</summary>
    ///<param name='english_str'>[in] The string to localize</param>
    public static MRhinoCommandOptionValue RMACOV(string english_str)
    {
      return new MRhinoCommandOptionValue(english_str, null);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="english_str"></param>
    /// <param name="context_id"></param>
    /// <returns></returns>
    public static MRhinoCommandOptionValue RMALocalizeCOV(string english_str, int context_id)
    {
      string s = Localize.RMALocalizeString(english_str, context_id);
      if (string.IsNullOrEmpty(s))
        s = english_str;
      return new MRhinoCommandOptionValue(english_str, s);
    }
    ///<summary>
    /// A form or user control should call this in its constructor if it wants to be localized
    /// the typical constructor for a localize form would look like:
    /// MyForm::MyForm()
    /// {
    ///   SuspendLayout();
    ///   InitializeComponent();
    ///   RMA::Localization::LocalizeForm( this );
    ///   ResumeLayout(true);
    /// }
    ///</summary>
    public static void LocalizeForm(Control form)
    {
      Localize.LocalizeFormInAssembly(Assembly.GetCallingAssembly(), form);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="a"></param>
    /// <param name="form"></param>
    public static void LocalizeFormInAssembly(Assembly a, Control form)
    {
      LocalizeUtils.LocalizeForm(a, Localize.m_current_language_id, form);
    }
    ///<summary>
    /// A form or user control should call this in its constructor if it wants to localize
    /// context menus that are set on the fly and not assigned to a forms control in design
    /// studio.
    /// MyForm::MyForm()
    /// {
    ///   SuspendLayout();
    ///   InitializeComponent();
    ///   RMA::Localization::LocalizeToolStripItemCollection( this, this.MyToolStrip.Items );
    /// }
    ///</summary>
    public static void LocalizeToolStripItemCollection(Control parent, ToolStripItemCollection collection)
    {
      LocalizeToolStripItemCollectionInAssembly(Assembly.GetCallingAssembly(), parent, collection);
    }
    /// <summary>
    /// 
    /// </summary>
    /// <param name="a"></param>
    /// <param name="parent"></param>
    /// <param name="collection"></param>
    public static void LocalizeToolStripItemCollectionInAssembly(Assembly a, Control parent, ToolStripItemCollection collection)
    {
      LocalizeUtils.LocalizeToolStripItemCollection(a, Localize.m_current_language_id, parent, collection);
    }
    /// <summary>
    /// 
    /// </summary>
    private static uint m_current_language_id;
  }
}
